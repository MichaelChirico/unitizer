
R version 4.1.0 alpha (2021-04-26 r80229)
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source(file.path("_helper", "init.R"))
> 
> # - "read_line works" ----------------------------------------------------------
> 
> # read through prompt vals
> 
> unitizer:::read_line_set_vals(letters[1:3])
> u.ns <- asNamespace("unitizer")
> unitizer:::read_line()
a
[1] "a"
> identical(u.ns$.global$prompt.vals, letters[2:3])
[1] TRUE
> unitizer:::read_line()
b
[1] "b"
> u.ns$.global$prompt.vals
[1] "c"
> unitizer:::read_line()
c
[1] "c"
> u.ns$.global$prompt.vals
character(0)
> 
> try(unitizer:::read_line())
Error : Internal Error: ran out of predefined readline input; contact maintainer.
> 
> # - "simple prompts" -----------------------------------------------------------
> 
> unitizer:::read_line_set_vals(c("y", "Y", "n", "N"))
> # expect_error(unitizer:::simple_prompt(1:5))
> try(unitizer:::simple_prompt(1:5))
Error in unitizer:::simple_prompt(1:5) : 
  Argument `message` must be character
> # expect_error(unitizer:::simple_prompt("hello", attempts = 1:5))
> try(unitizer:::simple_prompt("hello", attempts = 1:5))
Error in unitizer:::simple_prompt("hello", attempts = 1:5) : 
  Argument `attempts` must be numeric(1L), not NA, and one or greater
> # expect_error(unitizer:::simple_prompt("hello", values = NA_character_))
> try(unitizer:::simple_prompt("hello", values = NA_character_))
Error in unitizer:::simple_prompt("hello", values = NA_character_) : 
  Argument `values` must be character with no NAs
> # expect_error(unitizer:::simple_prompt("hello", case.sensitive = 1))
> try(unitizer:::simple_prompt("hello", case.sensitive = 1))
Error in unitizer:::simple_prompt("hello", case.sensitive = 1) : 
  Argument `case.sensitive` must be TRUE or FALSE
> 
> # capture.output(expect_identical("Y", unitizer:::simple_prompt("hello")))
> unitizer:::simple_prompt("hello")
| hello

unitizer> y
[1] "Y"
> # capture.output(expect_identical("Y", unitizer:::simple_prompt("hello")))
> unitizer:::simple_prompt("hello")#
| hello

unitizer> Y
[1] "Y"
> # capture.output(expect_identical("N", unitizer:::simple_prompt("hello")))
> unitizer:::simple_prompt("hello")
| hello

unitizer> n
[1] "N"
> # capture.output(expect_identical("N", unitizer:::simple_prompt("hello")))
> unitizer:::read_line_set_vals(c("y", "y", "n"))
> # expect_error(capture.output(unitizer:::simple_prompt("hello",
> #     attempts = 1L, case.sensitive = TRUE)), "Gave up trying to collect")
> try(unitizer:::simple_prompt("hello", attempts = 1L, case.sensitive = TRUE))
| hello

unitizer> y
| Invalid input, please select one of: Y, N

Error in unitizer:::simple_prompt("hello", attempts = 1L, case.sensitive = TRUE) : 
  Gave up trying to collect user input after 1 attempts.
> # expect_output(try(unitizer:::simple_prompt("hello", attempts = 1L,
> #     case.sensitive = TRUE), silent = TRUE), "hello\n.*Invalid input, please select one of: Y, N")
> try(unitizer:::simple_prompt("hello", attempts = 1L, case.sensitive = TRUE),
+     silent = TRUE)
| hello

unitizer> y
| Invalid input, please select one of: Y, N

> # expect_error(capture.output(unitizer:::simple_prompt("hello",
> #     attempts = 1L, case.sensitive = TRUE)), "Gave up trying to collect")
> try(unitizer:::simple_prompt("hello", attempts = 1L, case.sensitive = TRUE))
| hello

unitizer> n
| Invalid input, please select one of: Y, N

Error in unitizer:::simple_prompt("hello", attempts = 1L, case.sensitive = TRUE) : 
  Gave up trying to collect user input after 1 attempts.
> 
> # - "jaux prompt" --------------------------------------------------------------
> 
> unitizer:::read_line_set_vals(c("1 +", "1"))
> # expect_output(res <- unitizer:::faux_prompt(prompt = "> ", continue = "+ ")[[1L]],
> #     "> 1 \\+\n\\+ 1")
> res <- unitizer:::faux_prompt(prompt = "> ", continue = "+ ")[[1L]]
> 1 +
+ 1
> # expect_identical(res, quote(1 + 1))
> res
1 + 1
> unitizer:::read_line_set_vals(c("(})"))
> # expect_error(capture.output(unitizer:::faux_prompt(prompt = "> ",
> #     continue = "+ ")), "unexpected '\\}'")
> try(unitizer:::faux_prompt(prompt = "> ", continue = "+ "))
> (})
Error in "(})" : <text>:1:2: unexpected '}'
1: (}
     ^
> 
> # test_that("unitizer prompt", {
> #     expect_equal(txt, c("unitizer> 1 +", "+ 1", "[1] 2", "unitizer> H",
> #         "", "| No help available.", "| ", "| hello ([Y]es, [N]o, [Q]uit, [H]elp)?",
> #         "", "unitizer> Y", ""))
> #     expect_equal(txt2, c("unitizer> 1 +", "+ 1", "[1] 2", "unitizer> H",
> #         "", "| This is all the help you get", "| ", "| hello ([Y]es, [N]o, [Q]uit, [H]elp)?",
> #         "", "unitizer> Q", ""))
> #     expect_equal(txt3$message, c("Error in \"hell())\": <text>:1:7: unexpected ')'",
> #         "1: hell())", "          ^"))
> #     expect_equal(txt4, c("unitizer> {", "  1 + 1", "  2 + 1",
> #         "}", "[1] 3", "unitizer> N", ""))
> #     expect_error(unitizer:::unitizer_prompt("hello", valid.opts = c(Y = "[Y]es",
> #         N = "[N]o"), browse.env = "not an env", global = glob),
> #         "Argument `browse.env` must be an environment")
> #     expect_identical(res2, "Q")
> #     unitizer:::read_line_set_vals(character())
> #     expect_error(unitizer:::unitizer_prompt("hello", valid.opts = c(Y = "[Y]es",
> #         N = "[N]o"), global = glob), "Internal Error: ran out of predefined readline input",
> #         class = "readError")
> #     unitizer:::read_line_set_vals("1L")
> #     expect_error(capture.output(unitizer:::unitizer_prompt("hello",
> #         valid.opts = c(Y = "[Y]es", N = "[N]o"), exit.condition = unitizer:::exit_fun,
> #         valid.vals = 2:3, global = glob)), "Internal Error: ran out of predefined readline input")
> #     unitizer:::read_line_set_vals("2L")
> #     capture.output(res <- unitizer:::unitizer_prompt("hello",
> #         valid.opts = c(Y = "[Y]es", N = "[N]o"), exit.condition = unitizer:::exit_fun,
> #         valid.vals = 2:3, global = glob))
> #     expect_equal(res, 2L)
> # })
> # - "unitizer prompt" ----------------------------------------------------------
> 
> # Some of this needs to be done outside of testthat due to sinking
> suppressWarnings(glob <- unitizer:::unitizerGlobal$new())
> unitizer:::read_line_set_vals(c("1 +", "1", "H", "Y"))
> unitizer:::unitizer_prompt(
+   "hello", valid.opts = c(Y = "[Y]es", N = "[N]o"), global = glob
+ )
unitizer> 1 +
+ 1
[1] 2
unitizer> H

| No help available.
| 
| hello ([Y]es, [N]o, [Q]uit, [H]elp)?

unitizer> Y

[1] "Y"
> 
> unitizer:::read_line_set_vals(c("1 +", "1", "H", "Q"))
> unitizer:::unitizer_prompt("hello",
+     valid.opts = c(Y = "[Y]es", N = "[N]o"), help = "This is all the help you get",
+     global = glob)
unitizer> 1 +
+ 1
[1] 2
unitizer> H

| This is all the help you get
| 
| hello ([Y]es, [N]o, [Q]uit, [H]elp)?

unitizer> Q

[1] "Q"
> 
> unitizer:::read_line_set_vals(c("hell())", "Q"))
> txt3 <- unitizer:::capture_output(unitizer:::unitizer_prompt("hello",
+     valid.opts = c(Y = "[Y]es", N = "[N]o"), global = glob))
> txt3$message
[1] "Error in \"hell())\": <text>:1:7: unexpected ')'"
[2] "1: hell())"                                      
[3] "          ^"                                     
> 
> # and multiline stuff (#242)
> unitizer:::read_line_set_vals(c("{\n  1 + 1\n  2 + 1\n}", "N"))
> unitizer:::unitizer_prompt(
+   "hello", valid.opts = c(Y = "[Y]es", N = "[N]o"), global = glob
+ )
unitizer> {
  1 + 1
  2 + 1
}
[1] 3
unitizer> N

[1] "N"
> 
> # expect_equal(txt, c("unitizer> 1 +", "+ 1", "[1] 2", "unitizer> H",
> #     "", "| No help available.", "| ", "| hello ([Y]es, [N]o, [Q]uit, [H]elp)?",
> #     "", "unitizer> Y", ""))
> # expect_equal(txt2, c("unitizer> 1 +", "+ 1", "[1] 2", "unitizer> H",
> #     "", "| This is all the help you get", "| ", "| hello ([Y]es, [N]o, [Q]uit, [H]elp)?",
> #     "", "unitizer> Q", ""))
> # expect_equal(txt3$message, c("Error in \"hell())\": <text>:1:7: unexpected ')'",
> #     "1: hell())", "          ^"))
> # expect_equal(txt4, c("unitizer> {", "  1 + 1", "  2 + 1", "}",
> #     "[1] 3", "unitizer> N", ""))
> # expect_error(unitizer:::unitizer_prompt("hello", valid.opts = c(Y = "[Y]es",
> #     N = "[N]o"), browse.env = "not an env", global = glob), "Argument `browse.env` must be an environment")
> try(
+   unitizer:::unitizer_prompt(
+     "hello", valid.opts = c(Y = "[Y]es", N = "[N]o"),
+     browse.env = "not an env", global = glob
+ ) )
Error in unitizer:::unitizer_prompt("hello", valid.opts = c(Y = "[Y]es",  : 
  Argument `browse.env` must be an environment
> 
> unitizer:::read_line_set_vals(character())
> # expect_error(unitizer:::unitizer_prompt("hello", valid.opts = c(Y = "[Y]es",
> #     N = "[N]o"), global = glob), "Internal Error: ran out of predefined readline input",
> #     class = "readError")
> try(
+   unitizer:::unitizer_prompt(
+     "hello", valid.opts = c(Y = "[Y]es", N = "[N]o"), global = glob
+ ) )
Error : Internal Error: ran out of predefined readline input; contact maintainer.
> unitizer:::read_line_set_vals("1L")
> # expect_error(capture.output(unitizer:::unitizer_prompt("hello",
> #     valid.opts = c(Y = "[Y]es", N = "[N]o"), exit.condition = unitizer:::exit_fun,
> #     valid.vals = 2:3, global = glob)), "Internal Error: ran out of predefined readline input")
> try(
+   unitizer:::unitizer_prompt(
+     "hello",
+     valid.opts = c(Y = "[Y]es", N = "[N]o"),
+     exit.condition = unitizer:::exit_fun,
+     valid.vals = 2:3, global = glob
+ ) )
unitizer> 1L
| Type a number in `2:3` at the prompt
[1] 1
Error : Internal Error: ran out of predefined readline input; contact maintainer.
> unitizer:::read_line_set_vals("2L")
> # expect_equal(res, 2L)
> unitizer:::unitizer_prompt("hello", valid.opts = c(Y = "[Y]es",
+     N = "[N]o"), exit.condition = unitizer:::exit_fun, valid.vals = 2:3,
+     global = glob)
unitizer> 2L
[1] 2
> 
> 
> proc.time()
   user  system elapsed 
  0.693   0.080   0.758 
CLEANUP COMPLETE
