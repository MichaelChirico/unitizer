---
title: "unitizeR - Easy R Unit Tests"
author: "Brodie Gaslam"
date: "`r Sys.Date()`"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{01 - Introduction / Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

## Introduction

### Motivation

> it’s not that we don’t test our code, it’s that we don’t store our tests so they can be re-run automatically
>
> Hadley Wickham ([The R Journal Vol. 3/1, June 2011, P5](http://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf)).

`unitizer` automatically stores the informal tests you write during development that you might not bother to formalize into unit tests.  To use:

* Save your "informal" tests to an R file
* Run `unitize("my_file_name.R")`

By "informal" tests we mean anything you would type in the command line to test that your code is working as expected.

`unitize` will step through your tests in an interactive environment where you can review them and confirm they should be kept as unit tests.  That's it.  Any time you make changes to your project, you can just re-run `unitize` and it will alert you of any regressions.

### Demo

A big part of `unitizer` is the interactive environment.  It allows you to quickly review, add, and remove tests from your unit test store.  The best way to get a feel for the `unitizer` process is to run the provided demo:
```
library(unitizer)
demo(unitizer)
```
There is a [companion vignette](02democompanion.html) for the demo as well.

### How is `unitizer` Different to `testthat`?

`unitizer` trades off some formality for ease of use, and as with any trade-off, there are pros and cons.  Let's illustrate with some unit tests for the `base::log10` function.  First, as implemented in `testthat`:

```
expect_equal(
  log10(c(100, -100, 0, 1/10, Inf, -Inf, NA, 500)),
  c(2, NaN, -Inf, -1, Inf, NaN, NA, 2.69897000433602)
)
expect_warning(
  log10(c(100, -100, 0, 1/10, Inf, -Inf, NA, 500)),
  "NaNs produced"
)
expect_error(
  log10(letters),
  "Error in log10\\(letters\\) : non-numeric argument to mathematical function\n"
)
```
And as implemented in `unitizer`:
```
log10(c(100, -100, 0, 1/10, Inf, -Inf, NA, 500))  # succeed with warnings
log10(letters)                                    # input error
```
There are benefits to both approaches.  In favor of `unitizer`:

* Tests are easy to write
    * Notice how we don't need to provide the result vector for the first test
* Conditions are captured automatically
    * Values and warnings are both captured at the same time
    * Errors don't require any special handling

In favor of `testthat`:

* The tests are self documenting
    * Expected results are obvious from the source, whereas it is not so with `unitizer`
* Once you write the test you are done
    * With `unitizer` you still need to `unitize` and review the tests

The main selling point for `unitizer` is that the tests are easy to write.  This is particularly true when the return values from the tests are complex (e.g., conditions with messages, as shown above, or simply complex objects, as returned by `lm` for example).  You review the test result, confirm it is what it should be, and tell `unitizer` to store it.  There is no need to copy and paste awkward deparsed expressions into tests.

On the other hand, `unitizer` is not conducive to either self documentation or to test driven / [extreme](http://www.extremeprogramming.org/rules/testfirst.html) programming.  If these features are important to you then you are likely better off using more formal unit testing frameworks.

### `unitizer` and Packages

The simplest way to use `unitizer` as part of your package development process is to create a `tests/unitizer` folder for all your `unitizer` test scripts.  Then, in `tests`, add an additional file with calls to `unitize`.  Here is a sample test structure for our `unitizer.fastlm` demo package:
```
unitizer.fastlm/         # top level package directory
    R/
    tests/
        run.R            # <- calls `unitize`
        unitizer/
            fastlm.R
            cornerCases.R
```
And this is what the `run.R` file would look like
```
## file: tests/run.R
library(unitzer)
unitize("unitizer/fastlm.R")
unitize("unitizer/cornerCases.R")
```
The path specification for test files should be relative to the `tests` directory as that is what `R CMD check` effectively sets the working directory to before running the files in `tests/`.  This means you cannot just source your `run.R` file without also first setting the working directory to `tests/`.

When `unitize` is run by `R CMD check` it will run in a non-interactive mode that will succeed only if all tests pass.

There is also a `unitize_dir` function that will run `unitize` against all files in a directory.

Remember to include `unitizer` as a "suggests" package in your DESCRIPTION file.

## Quick Start

### Installation Instructions

Currently `unitizer` is only available on github:
```
library(devtools)
install_github("brodieg/unitizer")
```
### Running `unitizer`

1. Write some R expressions and save to a file (e.g. "my_test_file.R")
2. Type `unitize("my_test_file.R")` at the prompt
3. Follow interactive environment instructions

## Things You Should Know About `unitizer`

### `unitizer` Writes To Your Filesystem

#### Default Mode is to Store Tests in `rds` Files

`unitizer` stores unit tests and their results.  By default, it stores them in `rds` files in your filesystem.  You will be prompted before a file is saved to your filesystem.

 The `rds` file is placed in a directory with the same name as your test file, but with "unitizer" appended.  For example, if your tests are in "my_file_name.R", then `unitizer` will create a folder called "my_file_name.unitizer/" and put an `rds` file in it.

 See `?get_unitizer` for potential alternatives to saving to your file system.

#### File Space Considerations

If your tests produce massive objects, the `unitizer` `rds` file will be massive.  Try designing your tests so they will produce the smallest representative data structures needed for your tests to be useful.

Additionally, note that the `rds` files are binary, which needs to be accounted for when using them in version controlled projects.  See the version control section of the [esoteric topics vignette](06nittygritty.html).

#### Backup Your `unitizer` Stores

`unitizer` does not backup the `rds` beyond the single copy in the aforementioned folder.  Unit tests are valuable, and without the `rds` file `unitizer` tests become a lot less useful.  To the extent you backup your R test files, you should also backup the corresponding ".unitizer/" folder.  You could lose / corrupt your `unitizer` store in many ways.  Some non-exhaustive examples:

- Standard file system SNAFU
- Careless updates to existing `unitizer`
- `unitizer` developer accidentally introduces a bug that destroys your `unitizer`

Backup your `unitizer` stores!

### Tests are Evaluated in Clean Environments

Objects in `.GlobalEnv` will not be visible, and any non basic packages will be detached prior to test evaluation (you can re-attach them in your tests with `library`).  For more details see the [reproducible tests vignette](05reproducibletests.html).

### Tests Pass If They `all.equal` Stored Reference Values

Once you have created your first `unitizer` with `unitize`, subsequent calls to `unitize` will compare the old stored value to the new one using `all.equal`.  You can change the comparison function by using `unitizer_sect` (see [tests vignette](03tests.html)).

### `unitizer` Is Complex

In order to create an intuitive (hopefully) interactive unit testing framework we had to resort to a fair bit of trickery.  For the most part this trickery should be transparent to the user, but you should be aware it exists in the event something unexpected happens that exposes it.  Here is a non-exhaustive list of some of the tricky things we do:

* `library`, `require`, `attach`, and `detach` are `trace`d during `unitize` evaluation (see [reproducible tests vignette](05reproducibletests.html))
* Each tests is evaluated in its own environment, a child of the previous test's environment; because `R` looks up objects in parent environments it appears that all tests are evaluated one environment (see [interactive environment vignette](04interactiveenvironment.html))
* We provide modified versions of `quit`/`q` and `ls` (see [esoteric topics vignette](06nittygritty.html)) at the `unitizer` prompt
* `traceback` should work when reviewing tests that produce errors, but only because we capture the trace with `sys.calls` and write it to `base::.Traceback` during review
* We sink `stdout` and `stderr` during test evaluation to capture those streams; be careful if you are also sinking those streams (see [details on tests vignette](03tests.html))
* We parse the test file and extract comments so that they can be attached to the correct test for review
* The history file is temporary replaced so that your `unitizer` interactions don't pollute it

### Avoid Tests That Require User Input

In particular, you should avoid evaluating tests that invoke `debug`ged functions, or introducing interactivity by using something like `options(error=recover)`, or `readline`, or some such.  Tests will work, but the interaction will be challenging because you will have to do it with `stderr` and `stdout` captured...

## Acknowledgments

A big thank you to Hadley Wickham for devoting so much of his life to making the R universe a better place to live in.  `unitizer` borrows several concepts from `testthat`, and uses `testthat` for internal unit tests.  Additionally, we used `devtools` extensively during package development.
