#' @include testor.R

NULL

setGeneric("exec", function(x, ...) standardGeneric("exec"))

#' Manages Test Expression Evaluation
#' 
#' Runs test, captures value, stdout, stderr, conditions, etc.
#' 
#' @keywords internal
#' @param test the call to test
#' @param test.env the environment to evaluate the \code{`test`} in 
#' @return a \code{`\link{testorItem-class}`} object

setMethod("exec", "ANY", valueClass="testorItem",
  function(x, test.env) {
    if(!is.environment(test.env)) stop("Argument `test.env` must be an environment.")
    # Prep message and std output capture, note this is reset with every test expression
    # evaluation

    warn.opt <- getOption("warn")     # Need to ensure warn=1 so that things work properly
    err.opt <- getOption("error")
    std.err.capt <- tempfile()        # Inefficient to do this for every test? Convenient though
    std.out.capt <- tempfile()
    std.err.capt.con <- set_text_capture(std.err.capt, "message")
    std.out.capt.con <- set_text_capture(std.out.capt, "output")
    x.to.eval <- `attributes<-`(x, NULL)

    # Manage unexpected outcomes

    on.exit({  
      options(warn=warn.opt)
      options(error=err.opt)
      capt <- get_capture(std.err.capt.con, std.err.capt, std.out.capt.con, std.out.capt)
      file.remove(std.err.capt, std.out.capt)
      stop(
        "Unexpectedly exited evaluation attempt when executing test expression\n> ", 
        paste0(deparse(x.to.eval), collapse=""), 
        "\nmake sure you are not calling `runtests` inside a `tryCatch`/`try` block or ",
        "invoking a restart defined outside `runtests`; if you are not, contact ",
        "package maintainer."
      )
    } )
    # Evaluate expression

    value <- list(value=NULL, visible=FALSE)
    aborted <- FALSE
    trace <- NULL
    passed.eval <- FALSE
    conditions <- list()
    output <- message <- character()
    options(warn=1L)
    options(error=NULL)

    res <- eval_user_exp(x.to.eval, test.env)

    on.exit(NULL)
    options(warn=warn.opt)
    options(error=err.opt)

    # Revert settings, get captured messages, if any and if user isn't capturing already

    capt <- get_capture(std.err.capt.con, std.err.capt, std.out.capt.con, std.out.capt)
      if(aborted & is.call(x)) {   # check to see if `testor_sect` failed
      test.fun <- try(eval(x[[1L]], test.env), silent=TRUE)
      if(identical(test.fun, testor_sect)) {
        stop("Failed instantiating a testor section:\n", paste0(capt$message, "\n"))
    } }
    new(
      "testorItem", call=x.to.eval, value=res$value, 
      conditions=structure(res$conditions, class="condition_list"), 
      output=capt$output, message=capt$message, aborted=res$aborted, 
      env=test.env, comment=attr(x, "comment"), trace=res$trace
    )
} )
#' Utility function to evaluate user expressions
#' 
#' @keywords internal
#' @param testorUSEREXP an expression to evaluate
#' @param env environment the environment to evaluate the expression in 
#' @return TBD
#' @seealso exec, testor_prompt

eval_user_exp <- function(testorUSEREXP, env ) {
  passed.eval <- FALSE
  aborted <- FALSE
  conditions <- list()
  trace <- list()
  testorTESTRES <- NULL

  withRestarts(
    withCallingHandlers(
      {
        trace.base <- sys.calls()
        value <- withVisible(eval(testorUSEREXP, env))
        passed.eval <<- TRUE
        testorTESTRES <- value$value
        if(value$visible && length(testorUSEREXP)) {
          if(isS4(testorTESTRES)) show(testorTESTRES) else print(testorTESTRES)
      } },
      condition=function(cond) {
        attr(cond, "printed") <- passed.eval
        conditions[[length(conditions) + 1L]] <<- cond
        if(inherits(cond, "error")) {
          trace.new <- sys.calls()
          trace <<- get_trace(trace.base, trace.new, passed.eval)
      } }   
    ),
    abort=function() {
      aborted <<- structure(TRUE, printed=passed.eval)
    }
  )
  list(
    value=testorTESTRES,
    aborted=aborted,
    conditions=conditions,
    trace=trace
  )
}

#' Recompute a Traceback
#' 
#' Used for cases where the trace isn't generated because the error was run within
#' a handling loop, but we still want the trace so we can emulate command line
#' behavior.
#' 
#' This will modify the .Traceback system variable (see \code{`\link{traceback}`}
#' documentation).
#' 
#' Assumption right now is that the outer most call to \code{`withCallingHandlers`}
#' is the baseline level from which we want to repor the traceback.
#' 
#' @keywords internal
#' @param trace a list of type generated by sys.calls()
#' @return TRUE (only purpose of this is side effect)

set_trace <- function(trace) {
  if(length(trace)) assign(".Traceback", trace, envir=getNamespace("base"))
  TRUE
}
#' Collect the Call Stack And Clean-up
#' 
#' Only intended for use within \code{`eval_user_exp`}, will clean up the result
#' from two different \code{`sys.calls`} calls to extract the calls that a 
#' trace would show on error.
#' 
#' How much of the stack is used is affected by the \code{`passed.eval`} 
#' argument because if something didn't pass evaluation, it means the error
#' occurred within \code{`withVisible`} which in this setup means we need to
#' remove two additional levels.
#' 
#' Relies on calls being evaluated in a very particular environment.
#' 
#' @seealso set_trace
#' @param trace.base starting point for what we care about in the trace, as
#'   produced by \code{`sys.calls`}
#' @param trace.new the trace within the condition handler, as produced by 
#'   \code{`sys.calls`}
#' @param passsed.eval whether the evaluatation succeeded in the first step (see
#'   details)
#' @keywords internal

get_trace <- function(trace.base, trace.new, passed.eval) {
  
  # because withCallingHandlers/withRestarts don't register when calling
  # sys.calls() within them, but do when calling sys.calls() from the handling
  # function, we need to remove at least 4 calls from trace.new, and possibly
  # more if we ended up evaluating within withVisible

  if(
    length(trace.new) > length(trace.base) && 
    all(
      vapply(
        seq_along(trace.base), FUN.VALUE=logical(1L),
        function(x) identical(trace.base[[x]], trace.new[[x]])
    ) )
  ) {
    trace.new[seq_along(trace.base)] <- NULL
    if(length(trace.new) >= 7L || (passed.eval && length(trace.new) >= 4L)) {
      trace.new[1L:(if(passed.eval) 4L else 7L)] <- NULL
      if(length(trace.new) >= 2L) return(lapply(rev(head(trace.new, -2L)), deparse))
  } } 
  stop("Logic Error: couldn't extract trace; contact maintainer.")
}
