# unitizeR - Easy Unit Tests for R

## Introduction

### Motivation

> it’s not that we don’t test our code, it’s that we don’t store our tests so they can be re-run automatically
>
> Hadley Wickham ([The R Journal Vol. 3/1, June 2011, P5](http://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf)).

`unitizer` sets out to make storing these tests as easy as possible by blurring the line between informal in-development testing and formal unit testing.  For example to create unit tests with `unitizer`, you would:

* Save your "informal" tests to an R file
* Run `unitize("my_file_name.R")`

By "informal" tests we mean anything you would normally type in the command line when informally testing functionality.

`unitizer` will then:

* step through each test in your file
* have you review the test result as you would on the command line
* store the result if you confirm it is what it is supposed to be

You will need to review test results carefully, but only the first time.  Any time you make changes to your project, you can just re-run `unitize` and it will alert you if tests start producing different values or errors.

### Demo

A big part of `unitizer` is the interactive environment.  It is designed to allow you to quickly review, add, and remove tests from your unit test store.  The best way to get a feel for the `unitizer` process is to run the provided demo.  There is a companion vignette for the demo as well, though both the demo and the `unitizer` interactive environment provide documentation.

### How is `unitizer` Different to `testthat`?

`unitizer` trades off some formality for ease of use, and as with any trade-off, there are pros and cons.  We will illustrate some of these trade-offs with a contrived example.  Here are some unit tests for the base `log10` function as implemented in `testthat`:

```
## testthat.log10.R

expect_equal(
  log10(c(100, -100, 0, 1/10, Inf, -Inf, NA, 500)), 
  c(2, NaN, -Inf, -1, Inf, NaN, NA, 2.69897000433602)
)
expect_warning(log10(x), "NaNs produced")
expect_error(log10(letters), "Error in log10\\(letters\\) : non-numeric argument to mathematical function\n")
```

And as implemented in `unitizer`:

```
## unitizer.log10.R

log10(c(100, -100, 0, 1/10, Inf, -Inf, NA, 500))  # succeed with warnings
log10(letters)                                    # input error
```

This examples highlights benefits of both approaches.  In favor of `unitizer`:

* It just took a few seconds to write our tests
* Conditions are captured automatically
    * we do not need separate tests to check for warnings and values
    * error conditions are also captured without any special handling

In favor of `testthat`:

* The tests are self documenting: it is obvious from looking at them what the results should be, whereas it is not so for `unitizer`
* Once you write the test you're done, whereas with `unitizer` you still need to `unitize` them and confirm the results are as expected

The main selling point for `unitizer` is that the tests are very easy to write.  This is particularly helpful when the return values from the tests are complex (e.g., conditions with messages, as shown above, or simply complex objects, as returned by `lm` for example).  You review the test result, confirm it is what it should be, and tell `unitizer` to store it.  There is no need to copy and paste awkward deparsed expressions into tests.

On the other hand, `unitizer` is not conducive to either self documentation or to test driven / [extreme](http://www.extremeprogramming.org/rules/testfirst.html) programming.  If these features are important to you then you are likely better off using `testthat` or other more formal unit testing frameworks.

### `unitizer` and Packages

...

## Quick Start

### Installation

...

### Disclaimers

`unitizer` stores unit tests and their results.  By default, it stores them in `rds` files in a directory with the same name as your test file, but with "unitizer" appended.  For example, if your tests are in "my_file_name.R", then `unitizer` will create a folder called "my_file_name.unitizer/" and put an `rds` file in it.  If your tests produce massive objects, the `rds` file will be massive.

`unitizer` does not backup the `rds` beyond the single copy in the aforementioned folder.  Unit tests are valuable, and without the `rds` file `unitizer` tests become a lot less useful.  To the extent you backup your test R files, you should also backup the ".unitizer/" folder.

