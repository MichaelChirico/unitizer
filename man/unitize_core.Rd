% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/unitize.core.R
\name{unitize_core}
\alias{unitize_core}
\title{Runs The Basic Stuff}
\usage{
unitize_core(test.files, store.ids, interactive.mode, par.env,
  search.path.clean, search.path.keep, force.update, auto.accept, pre.load,
  mode)
}
\arguments{
\item{test.files}{character location of test files}

\item{store.ids}{list of store ids, same length as \code{test.files}}

\item{interactive.mode}{logical(1L) whether to run in interactive mode (
request user input when needed) or not (error if user input is required,
e.g. if all tests do not pass).}

\item{par.env}{NULL or environment, if NULL tests are run in a clean
environment, if an environment they are run with that environment as the
parent environment.}

\item{search.path.clean}{logical(1L) if TRUE all items on the search path
that are not part of a clean R session are detached prior to running tests.
Namespaces for detached packages remain loaded, so re-attaching those
packages during tests with \code{library} should carry little overhead.
The search path is restored to its initial state upon exiting
\code{unitizer} so any packages added/removed, or objects attached/detached
from search path are restored to original state.  See "Reproducible Tests"
vignette for details.}

\item{search.path.keep}{character any additional items on the search path
to keep attached; has no effect if \code{search.path.clean} is FALSE}

\item{force.update}{logical(1L) if TRUE will give the option to re-store a
unitizer after re-evaluating all the tests even if all tests passed.}

\item{auto.accept}{character(XL) ADVANCED USE ONLY: YOU CAN EASILY DESTROY
YOUR \code{unitizer} WITH THIS; whether to auto-accept tests without
prompting, use values in \code{c("new", "failed", "deleted", "error")} to
specify which type(s) of test you wish to auto accept (i.e. same as typing
\code{"Y"} at the \code{unitizer} prompt) or empty character vector to turn
off (default)}

\item{pre.load}{\code{NULL}, \code{FALSE}, a directory or a list of objects:
\itemize{
  \item if \code{NULL}, looks for a 'helper' directory in same directory as
    test file (or first test file if using \code{unitize_dir}) and
    \code{\link{sys.source}}s the files therein into an environment that
    has for parent \code{par.env}
  \item if a directory, then the same as \code{NULL}, except it uses files
    in the specified directory
  \item if a list transforms the list into an environment that has for
    parent \code{par.env}
  \item if \code{FALSE} does nothing
}
The environment generated by this process will be a parent to the
environments the tests are run in.  The primary purpose of this file is to
run \code{library} calls that are shared by multiple \code{unitizer} files.
Any packages you load in these files will be unloaded upon completion of
the \code{unitize} process unless you modify the \code{search.path.clean}
setting. You can also pre-load objects shared amongst tests, but you should
use this feature sparingly because these objects are not recorded in the
\code{unitizer}s and don't show up in \code{ls} calls from the
\code{unitizer} prompt, which makes it difficult to troubleshoot problems
related to those objects changing between \code{unitizer} runs}

\item{mode}{character(1L) one of "review" or "unitize"}
}
\description{
Used by both \code{\link{unitize}} and \code{\link{review}}
to launch the interactive interface for reviewing tests.
}
\details{
Right now we distinguish in what mode we're running based on whether
\code{test.file} is NULL (review mode) vs. not (unitize mode), which isn't
very elegant, but whatevs.  This has implications for the parsing / evaluation
step, as well as how the \code{unitizerBrowse} object is constructed.  Otherwise
stuff is mostly the same.

Cleary there is a trade-off in increased code complexity to handle both types
of code, vs duplication.  Not ideal, but tasks are so closely related and
there is so much common overhead, that the central function makes sense.
Also, since unfortunately we're relying on side-effects for some features, and
\code{on.exit} call for safe operation, it is difficult to truly modularize.
}
\keyword{internal}

