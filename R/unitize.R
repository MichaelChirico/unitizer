#' Unitize an R Test Script
#' 
#' Turns a standard R script into unit tests by evaluating the expressions and
#' storing them along with their resuls.  Re-running \code{`unitize`} then 
#' checks that the values remain unchanged.  See vignette for more details.
#' 
#' You can run \code{`unitize`} from the command line, or you can place one or
#' more \code{`unitize`} calls in an R file.
#'  
#' @export
#' @seealso \code{`\link{get_store}`}
#' @param test.file path to the file containing tests
#' @param store.id a folder to store the \code{`unitizer`} objects in; will auto-
#'   generate to a folder at the same location as the test file with the same
#'   name as the testfile, except ending in \code{`.unitizer`} instead of \code{`.R`}
#' @param interactive.mode logical(1L) whether to run in interactive mode

unitize <- function(
  test.file, store.id=sub("\\.[Rr]$", ".unitizer", test.file), 
  interactive.mode=interactive()
) {

  start.time <- proc.time()
  quit.time <- getOption("unitizer.prompt.b4.quit.time", 10)
  non.interactive <- getOption("unitizer.non.interactive", FALSE)  # need to rationalize this with `interactive.mode` param
  pack.env$base.packs <- pack.env$search <- search()  # record currently loaded packages

  if(!is.numeric(quit.time) || length(quit.time) != 1L || quit.time < 0)
    stop("Logic Error: unitizer option `unitizer.prompt.b4.quit.time` is miss-specified")
  if(!is.logical(non.interactive) || length(non.interactive) != 1L)
    stop("Logic Error: unitizer option `unitizer.non.interactive` is miss-specified")
  
  # Retrieve or create unitizer environment
  par.frame <- parent.frame()
  if(!is.character(test.file) || length(test.file) != 1L || !file_test("-f", test.file)) 
    stop("Argument `test.file` must be a valid path to a file")

  print(H1(paste0("unitizer for: ", test.file, collapse="")))

  if(inherits(try(unitizer <- get_store(store.id)), "try-error")) {
    stop("Unable to retrieve/create `unitizer` at location ", store.id, "; see prior errors for details.")
  }
  if(identical(unitizer, FALSE)) {
    unitizer <- new("unitizer", id=store.id, zero.env=new.env(parent=par.frame))
  } else if(!is(unitizer, "unitizer")){
    if(!identical(class(store.id), "character")) stop("Logic Error: `get_store.", class(store.id)[[1]], "` did not return a unitizer")
    stop("Logic Error: `get_store` did not return a unitizer; contact maintainer.")
  } else if(inherits(try(validObject(unitizer, complete=TRUE)), "try-error")) {
    if(
      inherits(version.compare <- try(unitizer@version < packageVersion("unitizer"), silent=TRUE), "try-error")
    ) {
      stop("Invalid `unitizer`; contact package maintainer")
    } else if (isTRUE(version.compare)) {
      message(
        "You are attempting to load a `unitizer` generated by an older version (", 
        unitizer@version, ") of `unitizer` vs. the currently loaded one (", packageVersion("unitizer"), 
        "). Do you wish to attempt to upgrade your `unitizer` to the new version ([Y]es, [N]o)?"
      )
      help <- paste0("Pressing Y will upgrade your `unitizer` to the newest version if possible")
      act <- unitizer_prompt(
        "Upgrade unitizer", new.env(par.frame), help, 
        valid.opts=c(Y="[Y]es", N="[N]o")
      )
      msg <- paste0(
        "If you don't wish to / can't automatically upgrade your unitizer you can re-",
        "run the tests with the version of unitizer you used to generate them in ",
        "the first place to ensure they still pass, manually delete the ",
        "corresponding RDS, and re-run the tests with the new version of `unitizer`."
      )
      if(identical(act, "Y")) {
        if(
          inherits(try(unitizer <- upgrade(unitizer)), "try-error") ||
          inherits(try(validObject(unitizer, complete=TRUE)), "try-error")
        ) {
          stop("Unable to upgrade. ", msg)
        }
        success <- try(set_store(store.id, unitizer))
        if(!inherits(success, "try-error")) 
          message("unitizer upgraded; please re-run tests")
        return(invisible(success))
      } else {
        stop("Cannot proceed with out of date `unitizer`. ", msg)
      } 
    } else {
      stop("Logic Error: unitizer appears corrupted in some way; contact maintainer.")
    }
  }
  # Make sure not running inside withCallingHandlers / withRestarts / tryCatch
  # or other potential issues; of course this isn't foolproof if someone is using
  # a variation on those functions, but also not the end of the world if it isn't
  # caught.

  call.stack <- sys.calls()
  if(
    any(
      vapply(
        call.stack, FUN.VALUE=logical(1L),
        function(x) 
          is.symbol(x[[1]]) && 
          as.character(x[[1]]) %in% 
          c("withCallingHandlers", "withRestarts", "tryCatch")
    ) )
  ) warning(
    "It appears you are running unitizer inside an error handling function such ",
    "as `withCallingHanlders`, `tryCatch`, or `withRestarts`.  This is strongly ",
    "discouraged as it may cause unpredictable behavior from `unitizer` in the ",
    "event tests produce conditions / errors.  We strongly recommend you re-run ",
    "your tests outside of such handling functions."
  )
  restarts <- computeRestarts()
  restart.names <- vapply(restarts, `[[`, character(1L), 1L)
  if("unitizerQuitExit" %in% restart.names)
    stop(
      "`unitizerQuitExit` restart is already defined; `unitizer` relies on this ",
      "restart to restore state prior to exit, so `unitizer` will not run if it is ",
      "defined outside of `unitize`.  If you did not define this restart contact ",
      "maintainer."
    )
  # Setup the new unitizer

  unitizer@id <- store.id
  parent.env(unitizer@zero.env) <- par.frame
  list2env(getItemFuns, unitizer@zero.env)     # functions for accessing unitizerItem contents
  assign("quit", unitizer_quit, unitizer@zero.env)
  assign("q", unitizer_quit, unitizer@zero.env)

  test.env <- new.env(parent=unitizer@items.new@base.env)
  wd <- getwd()                              # in case user changes it through tests
  on.exit(                                   # In case interrupted or some such 
    message(
      "Unexpectedly exited before storing `unitizer`; ",
      "tests were not saved or changed."
  ) )
  # Parse the test file

  if(inherits(try(tests.parsed <- parse_with_comments(test.file)), "try-error")) {
    warning("Unable to parse `test.file`; see prior error for details.  Proceeding without comment parsing")
    if(inherits(try(tests.parsed <- parse(test.file)), "try-error"))
      stop("Could not parse `test.file`; see prior error for details.")
  }
  if(!length(tests.parsed)) {
    message("No tests in ", test.file, "; nothing to do here.")
    on.exit(NULL)
    return(invisible(TRUE))
  }  
  # Evaluate the parsed calls

  tests <- new("unitizerTests") + tests.parsed
  unitizer <- unitizer + tests

  # Summary view of deltas and changes

  summary(unitizer)
  cat("\n")

  if(!interactive.mode || non.interactive) {
    delta.summ <- if(is.matrix(unitizer.summary)) {
      tail(unitizer.summary, 1L)[, -1L]
    } else {
      unitizer.summary[-1L]
    }
    if(any(delta.summ > 0L)) {  # Passed tests are first column
      delta.show <- unitizer@tests.status != "Pass" & !ignored(unitizer@items.new)
      message(
        paste0(
          format(paste0(unitizer@tests.status[delta.show], ": ")),
          unitizer@items.new.calls.deparse[delta.show],
          collapse="\n"
      ) )
      stop(
        "Newly generated tests do not match unitizer (", 
        paste(
          sub("^\\s*", "", names(delta.summ)), 
          delta.summ, sep=": ", collapse=", "
        ),
        "); see above for more info, or run in interactive mode"
      )
    }
    message("Passed Tests")
    on.exit(NULL)
    return(invisible(TRUE))
  }
  # Interactively decide what to keep / override / etc.
 
  tot.time <- (proc.time() - start.time)[["elapsed"]]
  unitizer <- withRestarts(
    browse(
      unitizer, env=new.env(par.frame),  # need to remove env=, doesn't do anything, but don't want to do it right now
      prompt.on.quit= tot.time >  quit.time
    ),
    noSaveExit=function() {
      message("Unitizer store was not modified.")
      FALSE
    },
    unitizerQuitExit=unitizer_quit_handler
  )
  on.exit(NULL)  # main failure points are now over so don't need to alert on failure
  
  # There are two conditions where return value the previous statement isn't a
  # unitizer, 1. if the restart is invoked, 2. if all tests passed in which case
  # there is nothing to do.

  if(!is(unitizer, "unitizer")) return(invisible(TRUE))

  if(!identical((new.wd <- getwd()), wd)) setwd(wd)  # Need to do this in case user code changed wd
  success <- try(set_store(store.id, unitizer))
  setwd(new.wd)
  if(!inherits(success, "try-error")) message("unitizer updated")
  return(invisible(success))
}
