#' @include item.R
#' @include testor.R

NULL

#' Prepares a \code{`testor`} Object for Review
#' 
#' Mainly, splits up the tests by section and subsection and creates an indexing
#' structure to keep track of what tests are in which section/subsection.  This
#' simplifies implementation of non-linear navigation through the tests.
#' 
#' @keywords internal
#' @param 

setGeneric("browsePrep", function(x, ...) standardGeneric("browsePrep"))
setMethod("browsePrep", "testor", 
  function(x, ...) {
    testor.browse <- new("testorBrowse")
    for(i in unique(x@section.parent)) {                           # Loop through parent sections
      sect.map <- x@section.map %in% which(x@section.parent == i)  # all items in parent section
      if(
        sum(vapply(x@sections[which(x@section.parent == i)], length, integer(1L))) == 0L || 
        ( 
          length(which(x@tests.fail & sect.map & !ignored(x@items.new))) == 0L && 
          length(which(x@tests.new & sect.map & !ignored(x@items.new))) == 0L && 
          length(which(x@tests.error & sect.map & !ignored(x@items.new))) == 0L
        )
      ) next
      browse.sect <- new(
        "testorBrowseSection", section.id=i, 
        section.title=x@sections[[i]]@title
      )
      browse.sect <- browse.sect + new(                            # Failed tests
        "testorBrowseSubSectionFailed",
        items.new=x@items.new[x@tests.fail & sect.map],
        show.fail=x@tests.errorDetails[x@tests.fail & sect.map], 
        items.ref=x@items.ref[x@items.new.map[x@tests.fail & sect.map]]
      )
      browse.sect <- browse.sect + new(                            # New tests
        "testorBrowseSubSectionNew",
        show.msg=TRUE, show.out=TRUE, 
        items.new=x@items.new[x@tests.new & sect.map]
      )
      browse.sect <- browse.sect + new(                            # Corrupted tests
        "testorBrowseSubSectionCorrupted",
        items.new=x@items.new[x@tests.error & sect.map],
        show.fail=x@tests.errorDetails[x@tests.error & sect.map], 
        items.ref=x@items.ref[x@items.new.map[x@tests.error & sect.map]]
      )
      testor.browse <- testor.browse + browse.sect
    }
    if(length(which(!ignored(x@items.ref[is.na(x@items.ref.map)])))) {  # Removed tests
      browse.sect <- new(
        "testorBrowseSection", section.id=max(x@section,parent) + 1L,
        section.title="Removed Tests"
      )
      browse.sect <- browse.sect + new(
        "testorBrowseSubSectionRemoved", 
        items.ref=x@items.ref[is.na(x@items.ref.map) & !ignored(x@items.ref)]
      )
      testor.browse <- testor.browse + browse.sect
    }
    testor.browse
  }
)
#' Keeps track of All Test Review Data
#' 
#' Seemed like a brilliant idea to make this an object to simplify validation, 
#' but as result cycling through the items is incredibly annoying.  Need to
#' develop better ways to iterate through each item while getting all the data
#' here, as well as ways of easily knowing which sections/subsections are
#' ignored.
#' 
#' The real issue with all this stuff is that \code{`item.new`} and 
#' \code{`item.ref`} can be NULL, and whether on or the other or neither are
#' NULL changes the processing logic.  Probably the thing to do is extract the
#' non NULL values (i.e. item.main) and store them in a list, along with a 
#' list highlighting which of \code{`item.new`} or \code{`item.ref`} has been
#' picked.
#' 
#' @slot item.id unique, 1 incrementing up to total number of reviewable items
#' @slot item.id.rel non-unique, unique within each sec/sub.sec
#' @slot reviewed whether a test has been reviewed
#' @slot review.val what action the user decided ("Y") is default
#' @keywords internal

setClass("testorBrowseMapping", 
  slots=c(
    item.id="integer",        
    item.id.rel="integer",    
    sec.id="integer",         
    sub.sec.id="integer",
    reviewed="logical",
    review.val="character",       
    review.type="factor",    
    ignored="logical"
  ),
  prototype=list(
    review.type=factor(levels=c("New", "Failed", "Removed", "Corrupted"))
  ),
  validity=function(object) {
    if(
      !identical(
        levels(object@review.type), 
        c("New", "Failed", "Removed", "Corrupted")
      ) || any(is.na(object@review.type))
    ) {
      return("Invalid slot `@review.type`")
    }
    TRUE
} )
#' Helper Object for Browsing 
#' 
#' Key element here is the \code{`@mapping`} slot which is generated by
#' \code{`\link{+,testorBrowse,testorBrowseSection-method}`}, which allows us
#' to navigate all the tests.

setClass("testorBrowse", contains="testorList",
  slots=c(
    mapping="testorBrowseMapping", 
    last.id="integer",         # used so that `reviewNext` knows what to show next
    last.reviewed="integer"    # used so that `reviewNext` knows what headers to display
  ),
  prototype=list(
    mapping=new("testorBrowseMapping"),
    last.id=0L,
    last.reviewed=0L
) )



#' Display Summary of Tests and User Decisions
#' 
#' Used to help navigate tests.  Will only show reviewed tests because
#' implementing the ability to skip ahead has several annoying implications
#' that we did not want to support (need to check that eventually all tests
#' are reviewed, etc.)
#' 
#' @keywords internal

setMethod("show", "testorBrowse", function(object) {
  # Split by section, then loop through each...
  # 
  # Section Title
  #   1. blah blah blah blah blah blah          New:Y
  #   2. blah blah blah blah blah blah       Failed:Y
  #   2. blah blah blah blah blah blah      Removed:Y
  #   3. blah blah blah blah blah blah    Corrupted:Y

  out <- character()
  disp.len <- getOption("width") - 11L - 4L - max(nchar(object@mapping@item.id))
  if(disp.len < 20L) disp.len <- 20L
  sec.id.prev <- 0L
  item.id.formatted <- format(object@mapping@item.id)
  review.formatted <- format(
    paste(object@mapping@review.type, object@mapping@review.val, sep=":"), 
    justify="right"
  )
  for(i in object@mapping@item.id) {
    
    if(object@mapping@ignored[[i]]) next
    
    sec.id <- object@mapping@sec.id[[i]]
    sub.sec.id <- object@mapping@sub.sec.id[[i]]
    id.rel <- object@mapping@item.id.rel[[i]]
    
    item <- if(is.null(object[[sec.id]][[sub.sec.id]]@items.new[[id.rel]])) {
      object[[sec.id]][[sub.sec.id]]@items.ref[[id.rel]]
    } else {
      object[[sec.id]][[sub.sec.id]]@items.new[[id.rel]]
    }
    if(!identical(sec.id.prev, sec.id)) {
      out <- c(out, object[[sec.id]]@sec.title)
      sec.id.prev <- sec.id
    }
    out <- c(
      out,
      paste0(
        "  ", item.id.formatted[[i]], ". ", 
        deparse_peek(item@call, disp.len)
      ),
      review.formatted[[i]]
    )
  }
  cat(out, sep="\n")
  invisible(out)
} )

#' Indicate Whether to Exit Review Loop
#' 
#' @keywords internal

setMethod("done", "testorBrowse", valueClass="logical",
  function(x, ...) {
    isTRUE(x@last.id >= max(x@mapping$item.id))
} )

#' Based on User Input, Return Either Reference Or New Items
#' 
#' Translates "Y", "N", etc. into c("A", "B", "C"), where "A" means return value 
#' from new item list, "B" return value from old item list (the original store)
#' and "C" means return NULL.
#' 
#' @keywords internal

setGeneric("processInput", function(x, ...) standardGeneric("processInput"))
setMethod("processInput", "testorBrowse", valueClass="testorItems",
  function(x, ...) {
    items <- new("testorItems")
    for(i in x@mapping@item.id) {
      sec <- x@mapping@sec.id[[i]]        # while it was nice to have mapping as an object for validation, this is terrible
      sub.sec <- x@mapping@sec.id[[i]]
      id.rel <- x@mapping@item.id.rel[[i]]
      input <- x@mapping@review.val[[i]]
      input.translate <- x[[sec]][[sub.sec]]@action[[input]]

      items <- items + switch(
        input.translate,                  
        A=x[[sec]][[sub.sec]]@items.new[id.rel],
        B=x[[sec]][[sub.sec]]@items.ref[id.rel],
        C=NULL
    ) }
    items
} )
#' Represents a \code{`testor_sect`}
#' @keywords internal

setClass("testorBrowseSection", contains="testorList",
  slots=c(
    section.id="integer", 
    section.title="character"
) )

#' Add Sections to Our Main Browse Object
#' 
#' Primarily we're contructing the \code{`@mapping`} slot which will then allow
#' us to carry out requisite computations later.  See \code{`\link{testorBrowseMapping}`}
#' for details on what each of the slots in \code{`mapping`} does
#' 
#' @keywords internal

setMethod("+", c("testorBrowse", "testorBrowseSection"), 
  function(e1, e2) {
    e1 <- append(e1, list(e2))
    item.count <- unlist(lapply(as.list(e2), length))
    test.types <- unlist(lapply(as.list(e2), slot, "title"))
    max.item <- length(e1@mapping)
    max.sub.sec <- max(e1@mapping$sub.sec.id)
    mapping.new <- new("testorBrowseMapping",         
      item.id=(max.item + 1L):(max.item + sum(item.count)),
      item.id.rel=unlist(lapply(item.count, seq)),
      sec.id=length(e1), 
      sub.sec.id=rep(
        (max.sub.sec + 1L):(max.sub.sec + length(e2)), each=item.count
      ),
      review.val="Y",                  # Default Action is Yes
      reviewed=FALSE,
      review.type=factor(
        rep(test.types, each=item.count), 
        levels=levels(e1@mapping@review.type)
      ),
      ignored=unlist(lapply(as.list(e2), ignored))
    )
    for(i in slotNames(e1@mapping)) {      
      slot(e1@mapping, i) <- c(slot(e1@mapping, i), slot(mapping.new, i))
    }
    e1
  }
)

#' Represents A Section/Action Type when Browsing
#' 
#' @keywords internal
#' @slot items.new the new items associated with this sub sections
#' @slot items.ref the reference items associated with this sub sections
#' @slot title character 1 length current test types (failed, added, removed, corrupted)
#' @slot prompt character 1 length what to prompt the user to do
#' @slot actions character 2 length containing c("A", "B", "C"), where "A"
#'   means return value from new item list, "B" return value from old item
#'   list (the original store) and "C" means return NULL.  The first value
#'   corresponds to the action on user typing `Y`, the second the action on 
#'   user typing `N`.
#' @slot show.msg logical whether to automatically show stderr produced during 
#'   evaluation
#' @slot show.out logical whether to automatically show stdout produced during 
#'   evaluation
#' @akir show.fail FALSE, or a testorItemsTestsErrors-class object if you want
#'   to show the details of failure

setClass("testorBrowseSubSection",
  slots=c(
    items.new="testorItemsOrNULL",
    items.ref="testorItemsOrNULL",
    title="character",
    prompt="character",
    detail="character",
    actions="character",
    show.out="logical",
    show.msg="logical",
    show.fail="testorItemsTestsErrorsOrLogical"
  ),
  validity=function(object) {
    if(
      !is.null(object@items.ref) && !is.null(object@items.new) && 
      length(object@items.ref) != length(object@items.new)
    ) {
      return("Ref list must have the same number of items as new list, or be NULL")
    } else if(is.null(object@items.ref) && is.null(object@items.new)) {
      return("Reference and New Items cannot both be NULL")
    } else if (
      !is.character(object@actions) || !all(object@actions %in% c("A", "B", "C")) || 
      length(object@actions) != length(unique(object@actions)) ||
      is.null(names(object@actions)) | !all(names(object@actions) %in% c("Y", "N"))
    ) {
      return("`actions` input incorrect")
    } else if (!is.logical(object@show.out) || length(object@show.out) != 1L) {
      return("Argument `show.out` must be a 1 length logical")
    } else if (!is.logical(object@show.msg) || length(object@show.msg) != 1L) {
      return("Argument `show.msg` must be a 1 length logical")
    } else if (
      !is(object@show.fail, "testorItemsTestsErrors") && 
      !identical(length(object@show.fail), 1L)
    ) {
      return("Argument `show.fail` must be a 1 length logical or a \"testorItemsTestsErrors\" object")
    } else if (!is.character(object@prompt) || length(object@prompt) != 1L) {
      return("Argument `prompt` must be a 1 length character")
    } else if (!is.character(object@detail) || length(object@detail) != 1L) {
      return("Argument `prompt` must be a 1 length character")
    }
    TRUE
  }
)
setMethod("length", "testorBrowseSubSection", 
  function(x) max(length(x@items.new), length(x@items.ref))
)
setMethod("ignored", "testorBrowseSubSection",
  function(x, ...) {
    sub.sect <- if(is.null(items.new)) items.ref else items.new
    vapply(as.list(sub.sect), ignored, logical(1L))
} )

#' Assemble Title for Display
#' 
#' Uses \code{`title`} slot

setGeneric("makeTitle", function(x, ...) standardGeneric("makeTitle"))
setMethod("makeTitle", "testorBrowseSubSection", 
  function(x, ...) paste0("Review ", length(x), " ", x@title, " Tests")
)

#' Specific Sub-Section defaults
#' @keywords internal

setClass("testorBrowseSubSectionFailed", contains="testorBrowseSubSection",
  slots=c(
    title="Failed",
    prompt="Overwrite item in store with new value",
    detail="Reference test does not match new test from test script.",
    actions=c(Y="A", N="B"), show.out=FALSE
) )
setClass("testorBrowseSubSectionNew", contains="testorBrowseSubSection",
  slots=c(
    title="New",
    prompt="Add new item to store", 
    detail="Test script contains tests not present in testor.",
    actions=c(Y="A", N="C"), show.out=TRUE
) )
setClass("testorBrowseSubSectionCorrupted", contains="testorBrowseSubSection",
  slots=c(
    title="Corrupted",
    prompt="Overwrite item in store with new value",
    detail=paste0(
      "Reference tests cannot be compared to new tests because errors occurred ",
      "while attempting comparison. Please review the error and contemplate using ",
      "a different comparison function with `testor_sect`."
    ),
    actions=c(Y="A", N="B"), show.out=FALSE
) )
setClass("testorBrowseSubSectionRemoved", contains="testorBrowseSubSection",
  slots=c(
    title="Removed",
    prompt="Remove item from store",
    detail="The following test exists in testor but not in the new test script.",
    actions=c(Y="C", N="B"), show.out=FALSE
) )

#' @keywords internal

setMethod("+", c("testorBrowseSection", "testorBrowseSubSection"), 
  valueClass="testorBrowseSection", 
  function(e1, e2) {
    e1 <- append(e1, list(e2))
  }
)