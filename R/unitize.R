#' Unitize an R Test Script
#'
#' Turn standard R scripts into unit tests by evaluating the expressions and
#' storing them along with their resuls.
#'
#' \code{`unitize`} creates unit tests from a single R file, and
#' \code{`unitize_dir`} creates tests from all the R files in the specified
#' directory (analogous to \code{`\link{testthat::test_dir}`}).
#'
#' \code{`review`} allows you to review existing \code{`unitizer`} or modify it
#' by dropping tests from it.  This is useful if you ever have second thoughts
#' about previously accepted tests and wish to inspect them.
#'
#' \code{`unitizer`} stores are identified by \code{`unitizer`} ids, which by
#' default are character strings containing the location of the folder the
#' \code{`unitizer`} RDS files are kept in.  \code{`unitize`} and
#' friends will create a \code{`unitizer`} id for you based on the test file
#' name and location, but you can specify your own location as an id, or even
#' use a completely different mechanism to store the \code{`unitizer`} data by
#' implementing S3 methods for \code{`\link{get_unitizer}`} and
#' \code{`\link{set_unitizer}`}.
#'
#' See \code{`unitizer`} vignettes and demo for details and examples.
#'
#' @export
#' @aliases review unitize_dir
#' @seealso \code{`\link{get_unitizer}`}
#' @param test.file path to the file containing tests
#' @param store.id a folder to store the \code{`unitizer`} objects in; will auto-
#'   generate to a folder at the same location as the test file with the same
#'   name as the testfile, except ending in \code{`.unitizer`} instead of
#'   \code{`.R`}.  This is the default option, you can create custom
#'   \code{`unitizer`} stores as well (see vignette and \code{`\link{get_unitizer}`}).
#' @param x for \code{`review`} only, either a \code{`unitizer`} or something that,
#'   when passed to \code{`\link{get_unitizer}`}, will retrieve a unitizer (i.e.
#'   equivalent to what would get passed in \code{`store.id`}).
#' @param interactive.mode logical(1L) whether to run in interactive mode
#' @param env.clean TRUE or environment, if TRUE tests are run in a clean
#'   environment, if an environment they are run with that environment as the
#'   parent environment.
#' @param search.path.clean logical(1L) if TRUE all items on the search path that
#'   are not part of a clean R session are detached prior to running tests.  Note
#'   namespaces for detached packages remain loaded.  Additionally, the search
#'   path is restored to its initial state upon exiting \code{`unitizer`} so any
#'   packages added/removed, or objects attached/detached from search path are
#'   restored to original state.  See "Reproducible Tests" vignette for details.
#' @param search.path.keep character any additional items on the search path
#'   to keep attached; has no effect if \code{`search.path.clean`} is FALSE
#' @param force.update logical(1L) if TRUE will give the option to re-store a
#'   unitizer after re-evaluating all the tests even if all tests passed.
#' @param test.dir the directory to run the tests on
#' @param test.file.regex a regular expression used to match which files in
#'   \code{`test.dir`} to \code{`unitize`}
#' @param unitizer.ids one of \itemize{
#'   \item a vectorized function that converts test file names to
#'     \code{`unitzer`} ids (see default value for example)
#'   \item a character vector with \code{`unitizer`} ids, must be the same
#'     length as the number of test files being reviewed
#'   \item a list of unitizer ids, must be the same length as the number of
#'     test files being reviewed; useful when you implement special storage
#'     mechanisms for the \code{`unitizers`} (see \code{`\link{get_unitizer}`})
#' }
#' @return the \code{`unitizer`} object updated as per user instructions,
#'   invisibly, or for \code{`unitize_dir`}, a list of the \code{`unitizer`}
#'   objects generated by each test file, invisibly

unitize <- function(
  test.file, store.id=sub("\\.[Rr]$", ".unitizer", test.file),
  interactive.mode=interactive(), env.clean=TRUE,
  search.path.clean=getOption("unitizer.search.path.clean"),
  search.path.keep=c("tools:rstudio", "package:unitizer"),
  force.update=FALSE
) {
  if(!is.character(test.file) || length(test.file) != 1L || !file_test("-f", test.file))
    stop("Argument `test.file` must be a valid path to a file")
  if(!is.logical(interactive.mode) || length(interactive.mode) != 1L || is.na(interactive.mode))
    stop("Argument `interactive.mode` must be TRUE or FALSE")
  if(!is.logical(force.update) || length(force.update) != 1L || is.na(force.update))
    stop("Argument `force.update` must be TRUE or FALSE")
  print(H1(paste0("unitizer for: ", test.file, collapse="")))
  invisible(
    unitizer_core(
      test.file, store.id, interactive.mode, env.clean, search.path.clean,
      search.path.keep, force.update=force.update
  ) )
}
#' @export
#' @rdname unitize

review <- function(
  x, env.clean=TRUE, search.path.clean=getOption("unitizer.search.path.clean"),
  search.path.keep=c("tools:rstudio", "package:unitizer")
) {
  u.name <- if(is.character(x) && length(x) == 1L) {
    x
  } else {
    u.name <- if(is(x, "unitizer")) x@id else x
    u.name <- try(as.character(u.name), silent=TRUE)
    if(inherits(u.name, "try-error")) u.name <- "<unknown>"

  }
  print(H1(paste0("unitizer for: ", u.name, collapse="")))
  invisible(
    unitizer_core(
      test.file=NULL, store.id=x, interactive.mode=TRUE, env.clean=env.clean,
      search.path.clean=search.path.clean, search.path.keep=search.path.keep,
      force.update=FALSE
    )
  )
}
#' @export
#' @rdname unitize

unitize_dir <- function(
  test.dir, test.file.regex="\\.[Rr]$",
  unitizer.ids=function(x) sub("\\.[Rr]$", ".unitizer", x),
  interactive.mode=interactive(), env.clean=TRUE,
  search.path.clean=getOption("unitizer.search.path.clean"),
  search.path.keep=c("tools:rstudio", "package:unitizer"),
  force.update=FALSE
) {
  # Basic validations

  if(!is.character(test.dir) || length(test.dir) != 1L || !file_test("-d", test.dir))
    stop("Argument `test.dir` must be character(1L).")
  if(
    !is.character(test.file.regex) || length(test.file.regex) != 1L ||
    is.na(test.file.regex)
  )
    stop("Argument `test.file.regex` must be character(1L) and not NA.")
  # Get the file names and corresponding unitizers

  test.files <- list.files(
    path=test.dir, pattern=test.file.regex, all.files=TRUE, full.names=TRUE,
    no..=TRUE
  )
  if(is.function(unitizer.ids)) {
    unitizer.ids <- try(unitizer.ids(test.files))
    err.txt <- "produced"
    if(inherits(unitizer.ids, "try-error")) {
      stop(
        "Argument `unitizer.ids` is a function, but caused an error when ",
        "attempting to use it to convert test file names to `unitizer` ids."
      )
    }
  } else {
    err.txt <- "is"
  }
  if(!identical(length(unitizer.ids), length(test.files))) {
    stop(
      "Argument `unitizer.ids` ", err.txt, " an object with the same number of ",
      "items (", length(unitizer.ids), ") as there are test files (",
      length(test.files), ") in `test.dir`."
    )
  }
  if(!is.character(unitizer.ids) && !is.list(unitizer.ids)) {
    stop(
      "Argument `unitizer.ids` ", err.txt, " an object of type ", typeof(unitizer.ids),
      " instead of a character vector or list as expected."
    )
  }
  # Now unitize; note we cannot try-catch as that would mess with the unitizer
  # evaluation system, so failure just kills the whole thing

  res <- vector(mode="list", length(test.files))

  for(i in seq_along(test.files)) {
    res[[i]] <- unitize(
      test.file=test.files[[i]], store.id=unitizer.ids[[i]],
      interactive.mode=interactive.mode, env.clean=env.clean,
      search.path.clean=search.path.clean,
      search.path.keep=search.path.keep, force.update=force.update
    )
  }
  invisible(res)
}
